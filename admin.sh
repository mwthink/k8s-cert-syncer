#!/bin/bash

K8S_CERT_SYNCER_VERSION="0.1.0"

function bincheck(){
  # Checks if required binaries are in PATH
  # Exits with error if any are missing
  REQ_BINS="jq kubectl"
  for rbin in $REQ_BINS; do
    if ! command -v $rbin &> /dev/null ; then
      echo "Fatal: Dependency \"${rbin}\" not found"
      exit 1
    fi
  done
}

function get_cert_secret_name(){
  kubectl -n ${SYNC_NAMESPACE} get cert ${SYNC_CERTIFICATE} -o json | jq -cr '.spec.secretName'
}

function get_rbac_name(){
  echo "cert-sync-${SYNC_CERTIFICATE}"
}

function generate_rbac(){
  rbac_name=$(get_rbac_name)
  kubectl -n ${SYNC_NAMESPACE} create sa ${rbac_name} --dry-run=client -o json
  kubectl -n ${SYNC_NAMESPACE} create role ${rbac_name} --verb=get --resource=secrets --resource-name=${CERT_SECRET_NAME} --dry-run=client -o json
  kubectl -n ${SYNC_NAMESPACE} create rolebinding ${rbac_name} --role=${rbac_name} --serviceaccount="${SYNC_NAMESPACE}:${rbac_name}" --dry-run=client -o json
}

function get_sa_creds(){
  sa_secret=$(kubectl -n ${SYNC_NAMESPACE} get sa $(get_rbac_name) -o json | jq -cr '.secrets[0].name')
  kubectl -n ${SYNC_NAMESPACE} get secret ${sa_secret} -o json | jq -cr '.data'
}

function mkscript(){
  CERT_SECRET_NAME=$(get_cert_secret_name)
  generate_rbac | kubectl apply -f - > /dev/null
  creds_json=$(get_sa_creds)

  cat <<EOF
#!/bin/sh
# Generated by k8s-cert-syncer v${K8S_CERT_SYNCER_VERSION}
cert_output_path="\${1}"
key_output_path="\${2}"

if [ -z "\$cert_output_path" ] || [ -z "\$key_output_path" ]; then
  echo "You must set an output path for BOTH the certificate and key"
  exit 1
fi

K8S_ENDPOINT="$(kubectl config view --minify -o json | jq -cr '.clusters[0].cluster.server')"
K8S_TOKEN="$(echo $creds_json | jq -cr '.token | @base64d')"
K8S_CA_B64="$(echo $creds_json | jq -cr '.["ca.crt"]')"
TLS_SECRET_NAME="${CERT_SECRET_NAME}"
TLS_SECRET_NS="$(echo $creds_json | jq -cr '.namespace | @base64d')"
CA_PEM_PATH="/tmp/k8ssync-ca.pem"
echo "\${K8S_CA_B64}" | base64 --decode > \$CA_PEM_PATH
cert_secret=\$(curl -s --cacert \${CA_PEM_PATH} --header "Authorization: Bearer \${K8S_TOKEN}" "\${K8S_ENDPOINT}/api/v1/namespaces/\${TLS_SECRET_NS}/secrets/\${TLS_SECRET_NAME}" | jq -cr '.')
echo \$cert_secret | jq -cr '.data["tls.crt"] | @base64d' > \$cert_output_path
echo \$cert_secret | jq -cr '.data["tls.key"] | @base64d' > \$key_output_path
EOF
}

function delscript(){
  rbac_name=$(get_rbac_name)
  kubectl -n ${SYNC_NAMESPACE} delete sa $rbac_name
  kubectl -n ${SYNC_NAMESPACE} delete role $rbac_name
  kubectl -n ${SYNC_NAMESPACE} delete rolebinding $rbac_name
}

function main(){
  bincheck
  if ! command -v $1 &> /dev/null ; then
    echo "$@ is not a valid command"
    exit 1
  fi
  SYNC_NAMESPACE="${2}"
  SYNC_CERTIFICATE="${3}"
  $@
}

main $@
